(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{209:function(t,v,e){"use strict";e.r(v);var a=e(6),_=Object(a.a)({},(function(){var t=this,v=t.$createElement,e=t._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h3",{attrs:{id:"理解vue核心概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#理解vue核心概念"}},[t._v("#")]),t._v(" 理解vue核心概念")]),t._v(" "),e("p",[t._v("记录下碎片学习~")]),t._v(" "),e("p",[t._v("Vue 2中很多核心的概念，作为前端工程师，需要知其然，知其所以然。\n因为无论你是出去面试，还是去面试别人都经常被问到或问到。\n所以就对一些概念的理解记录下来，方便自己理解。")]),t._v(" "),e("h3",{attrs:{id:"_1-mvvm响应式原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-mvvm响应式原理"}},[t._v("#")]),t._v(" 1.mvvm响应式原理")]),t._v(" "),e("h4",{attrs:{id:"关键步骤"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#关键步骤"}},[t._v("#")]),t._v(" 关键步骤")]),t._v(" "),e("p",[t._v("首先对属性添加响应式，对每个属性收集依赖dep，在每个属性set的时候，通知每个watcher（即依赖）去渲染更新。")]),t._v(" "),e("h4",{attrs:{id:"内部依赖收集是如何做到更新的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内部依赖收集是如何做到更新的"}},[t._v("#")]),t._v(" 内部依赖收集是如何做到更新的？")]),t._v(" "),e("p",[t._v("每个属性都有自己的依赖收集dep，当每个属性变化时会通知其依赖即watcher。")]),t._v(" "),e("h4",{attrs:{id:"缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[t._v("#")]),t._v(" 缺点")]),t._v(" "),e("p",[t._v("层级深需要递归添加响应式，性能不好；")]),t._v(" "),e("h3",{attrs:{id:"_2-vue如何检测数组变化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-vue如何检测数组变化"}},[t._v("#")]),t._v(" 2.vue如何检测数组变化")]),t._v(" "),e("p",[t._v("Vue选择重写数组方法，即劫持数组方法，重写原型链上的方法，不是用的defineProperty，那样性能太差。")]),t._v(" "),e("p",[t._v("在vue中修改数组的长度是无法监控到的，需要通过以上7种变异方法才能监控到。")]),t._v(" "),e("ul",[e("li",[t._v("vue如何重写的数组，是在Js原型上吗？不是。")]),t._v(" "),e("li",[t._v("vue是如何做的数组拦截，是继承了js原型上的方法。")])]),t._v(" "),e("h3",{attrs:{id:"_3-vue中模板编译原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-vue中模板编译原理"}},[t._v("#")]),t._v(" 3.vue中模板编译原理")]),t._v(" "),e("p",[t._v("将template转换成render函数，生成虚拟节点，经过处理，最后再生成dom。")]),t._v(" "),e("p",[t._v("这个过程主要用的vue-template-compiler,vue-loader处理的，用vue-template-compiler生成ast和render，render方法一执行就重新生成了dom(codeGen)")]),t._v(" "),e("p",[t._v("模板引擎的实现原理主要用的 with和new Function")]),t._v(" "),e("h3",{attrs:{id:"_4-生命周期钩子是如何实现的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-生命周期钩子是如何实现的"}},[t._v("#")]),t._v(" 4.生命周期钩子是如何实现的？")]),t._v(" "),e("p",[t._v("vue的生命周期钩子就是回调函数，当创建实例的时候会调用对应的方法。")]),t._v(" "),e("h3",{attrs:{id:"_5-mixin的使用场景和原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-mixin的使用场景和原理"}},[t._v("#")]),t._v(" 5.mixin的使用场景和原理")]),t._v(" "),e("p",[t._v("抽离公共的业务逻辑，类似于”继承“，")]),t._v(" "),e("p",[t._v("mixin可以提供全局数据，但不是共享的，不是vuex.")]),t._v(" "),e("p",[t._v("有缺陷：命名冲突问题。")]),t._v(" "),e("h3",{attrs:{id:"_6-nexttick在哪里使用和原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-nexttick在哪里使用和原理"}},[t._v("#")]),t._v(" 6.nextTick在哪里使用和原理？")]),t._v(" "),e("p",[t._v("nextTick中的回调是在下次dom更新循环结束后执行的回调（延迟执行）。避免循环渲染。")]),t._v(" "),e("p",[t._v("原理就是异步方法，用到了事件循环中的（宏任务和微任务）。")]),t._v(" "),e("p",[t._v("vue多次更新数据，最终会批处理更新。")]),t._v(" "),e("h3",{attrs:{id:"_7-vue为什么需要虚拟dom"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-vue为什么需要虚拟dom"}},[t._v("#")]),t._v(" 7.vue为什么需要虚拟dom")]),t._v(" "),e("p",[t._v("Virtual-dom就是用js对象来描述真实的dom,是对真实dom的抽象。由于直接操作dom性能低但是js的操作效率高，可以将dom操作转化成对象操作，最终通过diff算法比对差异进行更新dom,虚拟dom不依赖平台而能实现跨平台。")]),t._v(" "),e("h3",{attrs:{id:"_8-dom-diff的原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_8-dom-diff的原理"}},[t._v("#")]),t._v(" 8.dom-diff的原理")]),t._v(" "),e("p",[t._v("vue的diff算法是平级比较，不考虑跨级比较的情况。内部采用深度递归的方法+双指针的方式进行比较。")]),t._v(" "),e("p",[t._v("Vue2&vue3,react都是这个原理。")]),t._v(" "),e("h3",{attrs:{id:"_9-vue-set方法是如何实现的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_9-vue-set方法是如何实现的"}},[t._v("#")]),t._v(" 9.vue.set方法是如何实现的")]),t._v(" "),e("p",[t._v("为什么set可以触发更新。")]),t._v(" "),e("p",[t._v("如果是数组方法，调用我们重写的splice方法（这样可以更新视图）")]),t._v(" "),e("p",[t._v("如果是对象本身的属性，调用vue的定义响应式方法的，重新定义响应式。")]),t._v(" "),e("h3",{attrs:{id:"_10-父子组件之间如何通信"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_10-父子组件之间如何通信"}},[t._v("#")]),t._v(" 10.父子组件之间如何通信")]),t._v(" "),e("p",[t._v("props,事件，parent&children,provide&inject,$refs,")]),t._v(" "),e("p",[t._v("$attrs")]),t._v(" "),e("p",[t._v("Provide&inject可以实现跨级数据传递。$attrs主要是是实现批量传递数据，不能跨级。")]),t._v(" "),e("h3",{attrs:{id:"_11-vue的组件渲染流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_11-vue的组件渲染流程"}},[t._v("#")]),t._v(" 11.vue的组件渲染流程")]),t._v(" "),e("p",[t._v("创建时先父后子，卸载时先子后父。")]),t._v(" "),e("h3",{attrs:{id:"_12-vue中组件的data为什么是一个函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_12-vue中组件的data为什么是一个函数"}},[t._v("#")]),t._v(" 12.vue中组件的data为什么是一个函数")]),t._v(" "),e("p",[t._v("每次使用组件时都会创建一个实例，并且调用data函数返回一个对象作为组件的数据源，这样可以保证多个组件间数据不影响。")])])}),[],!1,null,null,null);v.default=_.exports}}]);